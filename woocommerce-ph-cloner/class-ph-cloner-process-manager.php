<?php
/**
 * Cloner Process Management class.
 *
 * @package PH_Cloner
 */

if ( ! defined( 'ABSPATH' ) ) {
	exit; // Exit if accessed directly.
}

/**
 * Class PH_Cloner_Process_Manager
 *
 * Manages the cloning process - order of steps, status of background processes, validation, tracking progress,
 * and doing startup and shutdown actions at beginning and end with process_init and process_finish.
 */
class PH_Cloner_Process_Manager {

	/**
	 * Errors generated by cloning process
	 *
	 * Important: notice this is multi-dimensional, unlike the flat $errors property of sections.
	 *
	 * @var array $errors {
	 *      @type string $message Description of error
	 *      @type string $section Optional id of section that generated the error
	 * }
	 */
	private $errors;
        
        	/**
	 * Singleton instance of this class
	 *
	 */
	private static $instance;
        
	/**
	 * PH_Cloner_Request constructor.
	 */
	private function __construct() {
            
	}


	/**
	 * Get singleton instance
	 *
	 * @return PH_Cloner_Process_Manager
	 */
	public static function instance() {
		if ( null === self::$instance ) {
			self::$instance = new self();
		}

		return self::$instance;
	}


        /**
	 * Start cloning process
	 */
	public function do_clone() {
		
                 // Don't allow more than one cloning process to be run at one time.
		if ( $this->is_in_progress() ) {
			ph_cloner_log()->log( __( 'A cloning process is already in progress. Please wait until it completes.', 'ph_cloner' ) );
			return;
		}

		// Delete the exit flag from the last time.
		delete_site_option( 'ph_cloner_exited' );

		// Trigger all the actions registered for this clone mode (start background processes, etc).
                 // Define the standard, default clone mode.
                ph_cloner_log()->set_start_time();
	       $this->create_site();
                //$this->copy_tables();
                //$this->copy_files();
                ph_cloner_log()->set_end_time();
                
	}

	/*
	______________________________________
	|
	|  Process Methods
	|_____________________________________
	*/

	/**
	 * Validate request variables for the current cloning mode
	 *
	 * This populates the $errors property but does nothing else - it is up to the
	 * calling function to check the value of $errors and determine action accordingly.
	 * Implements the 'ph_cloner_validation_errors' hook to allow things other than
	 * sections to perform validation if needed.
	 *
	 * @param string $section_id ID for specific section to validate ($id property of section class).
	 *      If blank, validate all sections that are supported for the current clone mode.
	 */
	public function validate( $section_id = '' ) {
	}


	/**
	 * Calls $this->finish only if all current processes are complete
	 *
	 * Sometimes this could get called twice in a short time window, so use locking.
	 * The lock, like PH_Cloner_Process::process_lock, uses direct database queries,
	 * not via transient or site options functions because those have caching that
	 * can get in the way.
	 */
	public function if_finished() {
                $progress = $this->get_progress();
                if ( 'complete' === $progress['status'] ) {
                        // Set a unique lock.
                        $finish_lock_id = wp_generate_password( 8 );
                        ph_cloner()->db->query(
                                ph_prepare_option_query(
                                        "INSERT INTO {table} ( {key}, {value} ) VALUES( %s, %s )",
                                        [ 'ph_cloner_finish_lock', $finish_lock_id ]
                                )
                        );
                        ph_cloner_log()->log( "SETTING finish lock *$finish_lock_id*" );
                        // Then wait 0.5 seconds and check again to make sure a simultaneous lock hasn't been set.
                        // If the set lock isn't from this (earlier) instance, bail and let the later instance take over.
                        usleep( apply_filters( 'ph_cloner_process_lock_delay', 0.5 * 1000000 ) );
                        $current_lock = $this->get_finish_lock();
                        if ( $current_lock !== $finish_lock_id ) {
                                ph_cloner_log()->log( "DETECTED simultaneous finish call *$current_lock*, ending" );
                                exit;
                        }
                        $this->finish();
                        // Remove lock for next time.
                        ph_cloner()->db->query(
                                ph_prepare_option_query(
                                        "DELETE FROM {table} WHERE {key} = %s",
                                        'ph_cloner_finish_lock'
                                )
                        );
                }else{
                    return false;
                }
	}

	/**
	 * Get the unique ID of the current finish lock, if there is one.
	 *
	 * @return string|null
	 */
	protected function get_finish_lock(){
		return ph_cloner()->db->get_var(
			ph_prepare_option_query(
				'SELECT {value} FROM {table} WHERE {key} = %s',
				'ph_cloner_finish_lock'
			)
		);
	}

	/**
	 * Finish the cloning process
	 */
	public function finish() {
		ph_cloner_log()->log( 'ENTERING *finish*' );
		$target_id     = ph_cloner_request()->get( 'target_id' );
		$target_title  = ph_cloner_request()->get( 'target_title' );
		$target_prefix = ph_cloner_request()->get( 'target_prefix' );

		// Use this do do any finish/cleanup/reporting actions.
		do_action( 'ph_cloner_process_finish' );

		// Update target title since it will have been overwritten by cloned options.
		// Use direct db query because otherwise object caching + cache flush can cause update to be lost.
		if ( ph_cloner_request()->is_mode( 'core' ) ) {
			if ( ! empty( $target_id ) && ! empty( $target_title ) ) {
				ph_cloner()->db->update(
					$target_prefix . 'options',
					[ 'option_value' => $target_title ],
					[ 'option_name' => 'blogname' ]
				);
			}
		}

		// Flush caches for clone over.
		switch_to_blog( $target_id );
		wp_cache_flush();
		restore_current_blog();

		// Log and report timing details.
		ph_cloner_log()->set_end_time();
		$start_time = ph_cloner_log()->get_start_time();
		$end_time   = ph_cloner_log()->get_end_time();
		$total_time = ph_cloner_log()->get_elapsed_time();
		$minutes    = floor( $total_time / 60 );
		$seconds    = ceil( $total_time % 60 );
		ph_cloner_log()->add_report( __( 'Start Time', 'ph-cloner-site-copier' ), $start_time );
		ph_cloner_log()->add_report( __( 'End Time', 'ph-cloner-site-copier' ), $end_time );
		ph_cloner_log()->add_report( __( 'Total Time', 'ph-cloner-site-copier' ), "{$minutes} min. {$seconds} sec." );
		ph_cloner_log()->log( 'END TIME: ' . $end_time );
		ph_cloner_log()->log( 'TOTAL_TIME: ' . "{$minutes} min. {$seconds} sec." );

		// Report details specific to the current mode (via report function provided when registering the mode).
		call_user_func( ph_cloner()->get_mode()->report );

		// Report number of items processed by each background process (tables, rows, users, files, etc).
		foreach ( $this->get_current_processes() as $process_id => $progress ) {
			$process = ph_cloner()->get_process( $process_id );
			if ( ! empty( $process->report_label ) ) {
				$completed = $progress['completed'];
				/* translators: number of items copied in clone operation */
				$report_string = _n( '%d item processed', '%d items processed', $completed, 'ph-cloner-site-copier' );
				ph_cloner_log()->add_report( $process->report_label, sprintf( $report_string, $completed ) );
			}
		}

		// Report number of text replacements made in site content.
		$replacements = (int) ph_cloner_log()->get_report( '_replacements' );
		/* translators: number of text replacements made on site content */
		$report_string = _n( '%d replacement made', '%d replacements made', $replacements, 'ph-cloner-site-copier' );
		ph_cloner_log()->add_report( __( 'Replacements', 'ph-cloner-site-copier' ), sprintf( $report_string, $replacements ) );

		// Clear all process data (except report).
		$this->exit_processes();
	}

	/**
	 * End all background processes and reset their data, plus clear saved reports and request data.
	 *
	 * @param mixed $error Optional error message to end log with if exiting unexpectedly.
	 */
	public function exit_processes( $error = '' ) {
		ph_cloner_log()->log( $error );

		// Cancel running background processes, as well as clear data from any completed ones.
		foreach ( $this->get_current_processes(true) as $process_id => $progress ) {
			$process = ph_cloner()->get_process( $process_id );
			$process->cancel();
		}

		// Save flag so that currently running batches can end (otherwise the data might be in memory
		// of another session and keep running for a while before realizing that the queue was cleared.
		update_site_option( 'ph_cloner_exited', '1' );

		// Log the current saved report data.
		ph_cloner_log()->log('REPORT DATA:'.ph_cloner_log()->get_all_reports());
                
                /* delete lock */
		ph_cloner()->db->query(
			ph_prepare_option_query(
				'DELETE FROM {table} WHERE {key} = %s',
				'ph_cloner_finish_lock'
			)
		);
		ph_cloner_request()->delete();
		ph_cloner_log()->end();
                 wp_die($error);
                    
	}

	/*
	______________________________________
	|
	|  Cloning Steps
	|_____________________________________
	*/

	/**
	 * Create a new site/blog on the network (step 1 for core mode)
	 */
	public function create_site() {
		$source_id    = ph_cloner_request()->get( 'source_id' );
		$target_name  = ph_cloner_request()->get( 'target_name', '' );
		$target_title = ph_cloner_request()->get( 'target_title', '' );

		// Sanitize.
		$target_name = strtolower( trim( $target_name ) );

		// Try to create new site.
		$source    = get_site( $source_id );
		$site_data = [
			'title'   => $target_title,
			'user_id' => ph_cloner_request()->get( 'user_id' ),
			'public'  => $source->public,
			'lang_id' => $source->lang_id,
		];
		if ( is_subdomain_install() ) {
			$site_data += [
				'domain' => $target_name . '.' . preg_replace( '|^www\.|', '', get_current_site()->domain ),
				'path'   => get_current_site()->path,
			];
		} else {
			$site_data += [
				'domain' => get_current_site()->domain,
				'path'   => get_current_site()->path . $target_name . '/',
			];
		}
		ph_cloner_log()->log( [ 'Attempting to create site with data:', $site_data ] );
		if ( function_exists( 'wp_insert_site' ) ) {
			$target_id = wp_insert_site( $site_data );
		} else {
			// Backwards compatibility for pre 5.1.
			$target_id = wpmu_create_blog(
				$site_data['domain'],
				$site_data['path'],
				$site_data['title'],
				$site_data['user_id']
			);
		}

		// Handle results.
		if ( ! is_wp_error( $target_id ) ) {
			ph_cloner_log()->log( "New site '$target_title' (" . get_site_url( $target_id ) . ') created.' );
			ph_cloner_request()->set( 'target_id', $target_id );
			ph_cloner_request()->set_up_vars();
			ph_cloner_request()->save();
		} else {
//@todo debug
//delete site and db tables
                    
        //wp_delete_site($target_id);        
			$this->exit_processes( 'Error creating site:' . $target_id->get_error_message() );
		}
	}

	/**
	 * Clone the source site's tables (step 2 for core mode)
	 */
	public function copy_tables() {
		$tables_process = ph_cloner()->get_process( 'tables' );
		$source_prefix  = ph_cloner_request()->get( 'source_prefix' );
		$target_prefix  = ph_cloner_request()->get( 'target_prefix' );
		$source_id      = ph_cloner_request()->get( 'source_id' );
		$target_id      = ph_cloner_request()->get( 'target_id' );

		// Makes sure that the target prefix is not somehow the same as the source.
		// Shouldn't be possible, but is irreversibly destructive if it does, so make sure.
		if ( $source_prefix === $target_prefix ) {
			$this->exit_processes( __( 'Source and target prefix the same. Cannot clone tables.', 'ph-cloner-site-copier' ) );
			return;
		}

		// Queue table cloning background process.
		$source_tables = ph_reorder_tables( ph_cloner()->get_site_tables( $source_id ) );
		foreach ( $source_tables as $source_table ) {
			$target_table = preg_replace( "|^$source_prefix|", $target_prefix, $source_table );
			$target_table = apply_filters( 'ph_cloner_target_table', $target_table );
			$table_data   = [
				'source_table' => $source_table,
				'target_table' => $target_table,
				'source_id'    => $source_id,
				'target_id'    => $target_id,
			];
			$tables_process->push_to_queue( $table_data );
			ph_cloner_log()->log( "QUEUEING clone of *$source_table* to *$target_table*" );
		}

		// Run Background Process for cloning tables.
		$tables_process->save()->dispatch();
	}

	/**
	 * Copy the source site's files (step 3 for core mode)
	 */
	public function copy_files() {
		$files_process = ph_cloner()->get_process( 'files' );
		$source_dir    = ph_cloner_request()->get( 'source_upload_dir' );
		$target_dir    = ph_cloner_request()->get( 'target_upload_dir' );

		// Makes sure that the target uploads dir is not somehow the same as the source.
		// Shouldn't be possible, but is irreversibly destructive if it does, so make sure.
		if ( $source_dir === $target_dir && ph_cloner_request()->get( 'do_copy_files', true ) ) {
			$this->exit_processes( __( 'Source and target uploads directories are the same. Cannot clone files.', 'ph-cloner-site-copier' ) );
			return;
		}

		// Queue file copy background process.
		$num_files = ph_recursive_dir_copy_by_process( $source_dir, $target_dir, $files_process );
		ph_cloner_log()->log( "QUEUEING *$num_files* files from *$source_dir* to *$target_dir*" );

		// Run background process for copying files.
		$files_process->save()->dispatch();
	}

	/*
	______________________________________
	|
	|  Manage Progress
	|_____________________________________
	*/

	/**
	 * Get progress data for currently running background process
	 *
	 * This uses current processes to get the progress data for each individual background process,
	 * and then it aggregates them together, much like PH_Cloner_Process::get_total_progress()
	 * aggregates batches into overall progress for the process, except this then further aggregates
	 * those by-process progress results into an overall view of the entire cloning operation, across
	 * all background processes.
	 *
	 * @return array|bool
	 */
	public function get_progress() {
		$by_process  = [];
		$total       = 0;
		$completed   = 0;
		$queue_empty = true;
		$processes   = $this->get_current_processes();

		// Otherwise - process must be in progress, so prepare progress data.
		foreach ( $processes as $process_id => $progress ) {
			$process = ph_cloner()->get_process( $process_id );
			// Calculate the combined total of expected and completed objects for all background processes.
			$total     += $progress['total'];
			$completed += $progress['completed'];
			// Make sure to check both for running and empty queue, because the queue could be empty
			// but still have a pending teleport request that was fired via $process->after_handle().
			if ( ! $process->is_queue_empty() || $process->is_process_running() ) {
				$queue_empty = false;
			}
			// Also prepare to return data for each individual process.
			$by_process[ $process_id ] = [
				'label'      => $process->report_label,
				'progress'   => $progress,
				'dispatched' => get_site_option( "ph_cloner_{$process_id}_process_dispatched" ),
				'nonce'      => $process->get_nonce(),
			];
		}
		return [
			'total'      => $total,
			'completed'  => $completed,
			'percentage' => $total > 0 ? round( ( 100 * $completed ) / $total ) : 0,
			'status'     => $queue_empty ? 'complete' : 'in_progress',
			'processes'  => $by_process,
		];
	}

	/**
	 * Get all background process batches in the database, and group by which process created them
	 *
	 * @param bool $suppress_filters Whether to enable checking all processes, or only a filtered subset.
	 * @return array
	 */
	private function get_current_processes( $suppress_filters = false ) {
		$processes     = [];
		$all_processes = ph_cloner()->processes;
		// Add filter here so that addons/mode can disable checking for unused processes to speed up code.
		if ( ! $suppress_filters ) {
			$all_processes = apply_filters('ph_cloner_processes_to_check', $all_processes);
		}
		ph_cloner_log()->log( 'CHECKING progress for processes:', implode(array_keys( $all_processes )) );
		foreach ( $all_processes as $process_id => $process ) {
			$progress = $process->get_total_progress();
			// Only add to the results if it this process has more than one object in it.
			// Check both the total (for normal cases), as well as is_queue_empty so that if
			// an error occurs and a process is running but missing progress data, it isn't invisible.
			if ( $progress['total'] > 0 || ! $process->is_queue_empty() ) {
				$processes[ $process_id ] = $progress;
			}
		}
		return $processes;
	}

	/**
	 * Check if there are any background processes in progress
	 *
	 * Note that this will return true if there are background processes with the status 'complete',
	 * even if none have the actual 'in_progress' status - the idea is that if they have not been
	 * cleared via $this->exit_processes(), the overall operation is still in progress.
	 *
	 * @param bool $suppress_filters Whether to enable checking all processes, or only a filtered subset.
	 * @return bool
	 */
	public function is_in_progress( $suppress_filters = false ) {
		return count( $this->get_current_processes( $suppress_filters ) ) > 0;
	}

}
/**
 * Get the current singleton request instance
 *
 * @return 
 */
function ph_cloner_process_manager() {
	return PH_Cloner_Process_Manager::instance();
}

